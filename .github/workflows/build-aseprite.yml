name: Build Aseprite

on:
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master, beta ]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to build (main, beta, or specific version)'
        required: false
        default: 'main'
      build_type:
        description: 'Build type'
        required: false
        default: 'RelWithDebInfo'
        type: choice
        options:
          - RelWithDebInfo
          - Release
          - Debug

env:
  BRANCH: ${{ github.event.inputs.branch || 'main' }}
  BUILD_TYPE: ${{ github.event.inputs.build_type || 'RelWithDebInfo' }}
permissions:
  contents: write
jobs:
  build-windows:
    name: Build on Windows
    runs-on: windows-2022
    
    steps:
    - name: Setup Developer Command Prompt
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64
        sdk: 10.0.26100.0

    - name: Install Dependencies
      shell: pwsh
      run: |
        # Install Ninja if not available
        if (-not (Get-Command ninja -ErrorAction SilentlyContinue)) {
          Write-Host "Installing Ninja..."
          choco install ninja -y
          refreshenv
        }
        
        # Install Git if needed
        if (-not (Test-Path "$env:ProgramFiles\Git\bin")) {
          Write-Host "Installing Git..."
          choco install git -y
          refreshenv
        }
        
        # Add Git to PATH for bash compatibility
        $gitPath = "$env:ProgramFiles\Git\bin;$env:ProgramFiles\Git\usr\bin;$env:ProgramFiles\Git\mingw64\bin"
        $env:Path = "$gitPath;$env:Path"
        [System.Environment]::SetEnvironmentVariable("Path", $env:Path, [System.EnvironmentVariableTarget]::Process)
        
        # Install curl and unzip if needed
        if (-not (Get-Command curl -ErrorAction SilentlyContinue)) {
          choco install curl -y
        }
        if (-not (Get-Command unzip -ErrorAction SilentlyContinue)) {
          choco install unzip -y
        }

    - name: Clone Aseprite
      shell: bash
      run: |
        git clone --recursive https://github.com/aseprite/aseprite.git
        cd aseprite
        
        # Checkout specific branch if specified
        if [ "${{ env.BRANCH }}" != "main" ]; then
          git fetch --all --tags
          git checkout ${{ env.BRANCH }}
        fi
        
        # Update submodules
        git submodule update --init --recursive

    - name: Detect Skia Version
      id: skia-version
      shell: bash
      run: |
        cd aseprite
        
        # Get the required Skia tag from laf/misc/skia-tag.txt
        if [ -f "laf/misc/skia-tag.txt" ]; then
          SKIA_TAG=$(cat laf/misc/skia-tag.txt)
          echo "Found Skia tag: $SKIA_TAG"
        else
          # Fallback to m124 if file doesn't exist
          SKIA_TAG="m124-08a5439a6b"
          echo "Using default Skia tag: $SKIA_TAG"
        fi
        
        # Extract the Skia directory name (e.g., m124 from m124-08a5439a6b)
        SKIA_DIR_NAME="skia-$(echo $SKIA_TAG | cut -d '-' -f 1)"
        
        echo "SKIA_TAG=$SKIA_TAG" >> $GITHUB_OUTPUT
        echo "SKIA_DIR_NAME=$SKIA_DIR_NAME" >> $GITHUB_OUTPUT
        
        # Determine branch type for base branch detection
        BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
        if [[ "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "beta" ]]; then
          BASE_BRANCH="$BRANCH_NAME"
        else
          # Check if this branch is based on beta or main
          if git branch --contains origin/beta | grep -q "^\* $BRANCH_NAME\$" 2>/dev/null; then
            BASE_BRANCH="beta"
          else
            BASE_BRANCH="main"
          fi
        fi
        echo "BASE_BRANCH=$BASE_BRANCH" >> $GITHUB_OUTPUT

    - name: Cache Skia
      id: cache-skia
      uses: actions/cache@v4
      with:
        path: C:/deps/${{ steps.skia-version.outputs.SKIA_DIR_NAME }}
        key: skia-${{ steps.skia-version.outputs.SKIA_TAG }}-windows-${{ env.BUILD_TYPE }}-v3

    - name: Download Skia
      if: steps.cache-skia.outputs.cache-hit != 'true'
      shell: bash
      run: |
        cd aseprite
        
        # Create deps directory
        mkdir -p /c/deps/${{ steps.skia-version.outputs.SKIA_DIR_NAME }}
        cd /c/deps/${{ steps.skia-version.outputs.SKIA_DIR_NAME }}
        
        # Determine which Skia build to download
        if [[ "${{ env.BUILD_TYPE }}" == "Debug" ]]; then
          SKIA_BUILD="Debug"
        else
          SKIA_BUILD="Release"
        fi
        
        # Get the Skia URL using the laf script
        if [ -f "$GITHUB_WORKSPACE/aseprite/laf/misc/skia-url.sh" ]; then
          SKIA_URL=$(bash $GITHUB_WORKSPACE/aseprite/laf/misc/skia-url.sh $SKIA_BUILD)
        else
          # Fallback URL construction if script doesn't exist
          SKIA_URL="https://github.com/aseprite/skia/releases/download/${{ steps.skia-version.outputs.SKIA_TAG }}/Skia-Windows-${SKIA_BUILD}-x64.zip"
        fi
        
        echo "Downloading Skia from: $SKIA_URL"
        SKIA_FILE=$(basename $SKIA_URL)
        
        # Download Skia
        curl --ssl-revoke-best-effort -L -o "$SKIA_FILE" "$SKIA_URL"
        
        # Extract Skia
        unzip -n "$SKIA_FILE"
        
        # Verify extraction
        if [[ "${{ env.BUILD_TYPE }}" == "Debug" ]]; then
          EXPECTED_DIR="out/Debug-x64"
        else
          EXPECTED_DIR="out/Release-x64"
        fi
        
        if [ ! -d "$EXPECTED_DIR" ]; then
          echo "Error: Expected Skia directory $EXPECTED_DIR not found after extraction"
          ls -la
          exit 1
        fi
        
        echo "Skia downloaded and extracted successfully"

    - name: Configure with CMake
      shell: bash
      run: |
        cd aseprite
        
        # Set up paths
        SOURCE_DIR="$PWD"
        BUILD_DIR="$PWD/build"
        SKIA_DIR="/c/deps/${{ steps.skia-version.outputs.SKIA_DIR_NAME }}"
        
        # Determine Skia library directory based on build type
        if [[ "${{ env.BUILD_TYPE }}" == "Debug" ]]; then
          SKIA_LIBRARY_DIR="$SKIA_DIR/out/Debug-x64"
        else
          SKIA_LIBRARY_DIR="$SKIA_DIR/out/Release-x64"
        fi
        
        echo "======================== CONFIGURATION ========================"
        echo "Build type: ${{ env.BUILD_TYPE }}"
        echo "Build dir: $BUILD_DIR"
        echo "Source dir: $SOURCE_DIR"
        echo "Skia dir: $SKIA_DIR"
        echo "Skia library dir: $SKIA_LIBRARY_DIR"
        echo "Branch: ${{ steps.skia-version.outputs.BASE_BRANCH }}"
        
        # Run CMake configuration (following build.sh pattern)
        cmake -B "$BUILD_DIR" -S "$SOURCE_DIR" -G Ninja \
              -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
              -DLAF_BACKEND=skia \
              -DSKIA_DIR="$SKIA_DIR" \
              -DSKIA_LIBRARY_DIR="$SKIA_LIBRARY_DIR"

    - name: Build Aseprite
      shell: bash
      run: |
        cd aseprite
        echo "============================== BUILDING =============================="
        cmake --build build -- aseprite

    - name: Install OpenSSL 1.1.x to current directory
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        
        # Get current working directory 
        $currentDir = (Get-Location).Path
        $opensslDir = Join-Path $currentDir "OpenSSL-Win64"
        
        Write-Host "Installing OpenSSL 1.1.x to: $opensslDir"
        
        # Create directory if it doesn't exist
        New-Item -Path $opensslDir -ItemType Directory -Force | Out-Null
        
        # Install OpenSSL with custom directory using install arguments
        # The /DIR= parameter is passed to the underlying installer
        try {
          choco install openssl --version=1.1.1.1400 -y --force --install-arguments="'/DIR=$opensslDir'"
        } catch {
          Write-Host "First attempt failed, trying with different approach..."
          try {
            choco install openssl11 -y --force --install-arguments="'/DIR=$opensslDir'"
          } catch {
            Write-Host "Second attempt failed, trying openssl.light..."
            choco install openssl.light -y --force --install-arguments="'/DIR=$opensslDir'"
          }
        }
        
        Write-Host "Installation completed. Checking results..."
        
        # Verify installation
        if (Test-Path $opensslDir) {
          Write-Host "✓ OpenSSL installed successfully to: $opensslDir"
          Write-Host "Directory contents:"
          Get-ChildItem $opensslDir -Recurse | Select-Object -First 20 | ForEach-Object { 
            Write-Host "  $($_.FullName)" 
          }
        } else {
          Write-Host "✗ Installation may have failed. Searching for OpenSSL..."
          # Search for any OpenSSL installation
          $found = Get-ChildItem $currentDir -Recurse -Directory -Name "*OpenSSL*" -ErrorAction SilentlyContinue
          if ($found) {
            Write-Host "Found OpenSSL directories: $($found -join ', ')"
          }
        }

    - name: Enhanced Debug - Find OpenSSL DLLs
      shell: pwsh
      run: |
        Write-Host "=== Searching for OpenSSL 1.1 DLLs ==="
        
        $currentDir = (Get-Location).Path
        $searchPaths = @(
          "$currentDir\OpenSSL-Win64",
          "$currentDir\OpenSSL-Win64\bin", 
          "$currentDir\OpenSSL",
          "$currentDir\OpenSSL\bin"
        )
        
        # Add any directories we find that contain OpenSSL
        $foundDirs = Get-ChildItem $currentDir -Recurse -Directory -Name "*OpenSSL*" -ErrorAction SilentlyContinue
        foreach ($dir in $foundDirs) {
          $fullPath = Join-Path $currentDir $dir
          $searchPaths += $fullPath
          $searchPaths += Join-Path $fullPath "bin"
        }
        
        $dlls = @('libcrypto-1_1-x64.dll', 'libssl-1_1-x64.dll')
        $foundDlls = @{}
        
        foreach ($dll in $dlls) {
          Write-Host "`nSearching for $dll..."
          foreach ($path in $searchPaths) {
            if (Test-Path $path) {
              $found = Get-ChildItem $path -Filter $dll -ErrorAction SilentlyContinue
              if ($found) {
                Write-Host "  ✓ Found: $($found.FullName)"
                $foundDlls[$dll] = $found.FullName
                break
              }
            }
          }
          if (-not $foundDlls.ContainsKey($dll)) {
            Write-Host "  ✗ $dll not found in expected locations"
          }
        }
        
        # If not found in expected locations, search the entire current directory tree
        foreach ($dll in $dlls) {
          if (-not $foundDlls.ContainsKey($dll)) {
            Write-Host "Performing broader search for $dll..."
            $found = Get-ChildItem $currentDir -Recurse -Filter $dll -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($found) {
              Write-Host "  ✓ Found via broad search: $($found.FullName)"
              $foundDlls[$dll] = $found.FullName
            }
          }
        }
        
        Write-Host "`n=== Search Summary ==="
        foreach ($dll in $dlls) {
          if ($foundDlls.ContainsKey($dll)) {
            Write-Host "✓ $dll : $($foundDlls[$dll])"
          } else {
            Write-Host "✗ $dll : NOT FOUND"
          }
        }

    - name: Bundle OpenSSL 1.1 DLLs (Fixed)
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        
        # Destination = the already-existing build output folder
        $dest = "$(Resolve-Path 'aseprite/build/bin')"
        $currentDir = (Get-Location).Path
        
        # Search paths in the current directory
        $searchPaths = @(
          "$currentDir\OpenSSL-Win64\bin",
          "$currentDir\OpenSSL-Win64", 
          "$currentDir\OpenSSL\bin",
          "$currentDir\OpenSSL"
        )
        
        # Add any OpenSSL directories we can find
        $opensslDirs = Get-ChildItem $currentDir -Recurse -Directory -Name "*OpenSSL*" -ErrorAction SilentlyContinue
        foreach ($dir in $opensslDirs) {
          $fullPath = Join-Path $currentDir $dir
          $searchPaths += $fullPath
          $searchPaths += Join-Path $fullPath "bin"
        }
        
        # Filter to only existing paths
        $existingPaths = $searchPaths | Where-Object { Test-Path $_ }
        
        Write-Host "Searching in paths: $($existingPaths -join ', ')"
        
        $crypto = $null
        $ssl = $null
        
        # Search for the DLLs
        foreach ($path in $existingPaths) {
          if (-not $crypto) { 
            $crypto = Get-ChildItem $path -Recurse -Filter 'libcrypto-1_1-x64.dll' -ErrorAction SilentlyContinue | Select-Object -First 1 
          }
          if (-not $ssl) { 
            $ssl = Get-ChildItem $path -Recurse -Filter 'libssl-1_1-x64.dll' -ErrorAction SilentlyContinue | Select-Object -First 1 
          }
          
          # Break early if we found both
          if ($crypto -and $ssl) { break }
        }
        
        # If still not found, search the entire current directory tree (last resort)
        if (-not $crypto) {
          Write-Host "Performing broad search for libcrypto-1_1-x64.dll..."
          $crypto = Get-ChildItem $currentDir -Recurse -Filter 'libcrypto-1_1-x64.dll' -ErrorAction SilentlyContinue | Select-Object -First 1
        }
        if (-not $ssl) {
          Write-Host "Performing broad search for libssl-1_1-x64.dll..."
          $ssl = Get-ChildItem $currentDir -Recurse -Filter 'libssl-1_1-x64.dll' -ErrorAction SilentlyContinue | Select-Object -First 1
        }
        
        # Check if we found everything
        if (-not $crypto -or -not $ssl) { 
          Write-Host "ERROR: Could not find required OpenSSL 1.1 DLLs"
          Write-Host "Crypto DLL: $(if($crypto) { $crypto.FullName } else { 'NOT FOUND' })"
          Write-Host "SSL DLL: $(if($ssl) { $ssl.FullName } else { 'NOT FOUND' })"
          
          # List all DLLs we can find for debugging
          Write-Host "`nAll DLLs found in current directory:"
          Get-ChildItem $currentDir -Recurse -Filter "*.dll" -ErrorAction SilentlyContinue | 
            Where-Object { $_.Name -like "*ssl*" -or $_.Name -like "*crypto*" } |
            ForEach-Object { Write-Host "  $($_.FullName)" }
            
          throw "Could not find OpenSSL 1.1 DLLs"
        }

        Write-Host "Found DLLs:"
        Write-Host "  Crypto: $($crypto.FullName)"
        Write-Host "  SSL: $($ssl.FullName)"

        # Copy the DLLs
        Copy-Item $crypto.FullName -Destination $dest -Force
        Copy-Item $ssl.FullName -Destination $dest -Force
        
        Write-Host "✓ Successfully bundled OpenSSL DLLs into $dest"
        
        # Verify the files were copied
        $copiedCrypto = Join-Path $dest $crypto.Name
        $copiedSsl = Join-Path $dest $ssl.Name
        
        if ((Test-Path $copiedCrypto) -and (Test-Path $copiedSsl)) {
          Write-Host "✓ Verification: DLLs successfully copied to destination"
          Write-Host "  $copiedCrypto"
          Write-Host "  $copiedSsl"
        } else {
          throw "Verification failed: DLLs were not copied successfully"
        }

    - name: Package Artifacts (Windows zip via PowerShell)
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'
        
        Push-Location aseprite
        $artifactDir = "aseprite-windows-${{ env.BUILD_TYPE }}"
        
        if (Test-Path $artifactDir) { Remove-Item $artifactDir -Recurse -Force }
        New-Item -ItemType Directory -Path $artifactDir | Out-Null
        
        Copy-Item -Recurse -Force "build/bin" $artifactDir
        
        $buildInfo = @"
        Aseprite Build Information
        ==========================
        Branch: ${{ env.BRANCH }}
        Base Branch: ${{ steps.skia-version.outputs.BASE_BRANCH }}
        Build Type: ${{ env.BUILD_TYPE }}
        Skia Version: ${{ steps.skia-version.outputs.SKIA_TAG }}
        Build Date: $(Get-Date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss 'UTC'")
        Commit: $(git rev-parse HEAD)
        
        To run Aseprite:
        1. Extract all files
        2. Run aseprite.exe
        
        Note: This is an unofficial build. Consider purchasing Aseprite
        from https://www.aseprite.org/ to support the developers.
        "@
        Set-Content -Path (Join-Path $artifactDir "BUILD_INFO.txt") -Value $buildInfo -NoNewline
        
        $zipPath = "aseprite-windows-${{ env.BUILD_TYPE }}.zip"
        if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
        Compress-Archive -Path "$artifactDir\*" -DestinationPath $zipPath -CompressionLevel Optimal
        Pop-Location

    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: aseprite-windows-${{ env.BUILD_TYPE }}-${{ github.run_number }}
        path: aseprite/aseprite-windows-${{ env.BUILD_TYPE }}.zip
        retention-days: 30

  build-macos:
    name: Build on macOS
    runs-on: macos-latest
    
    steps:
    - name: Install Dependencies
      run: |
        brew install cmake ninja

    - name: Clone Aseprite
      run: |
        git clone --recursive https://github.com/aseprite/aseprite.git
        cd aseprite
        
        if [ "${{ env.BRANCH }}" != "main" ]; then
          git fetch --all --tags
          git checkout ${{ env.BRANCH }}
        fi
        
        git submodule update --init --recursive

    - name: Detect Skia Version
      id: skia-version
      run: |
        cd aseprite
        
        if [ -f "laf/misc/skia-tag.txt" ]; then
          SKIA_TAG=$(cat laf/misc/skia-tag.txt)
        else
          SKIA_TAG="m124-08a5439a6b"
        fi
        
        SKIA_DIR_NAME="skia-$(echo $SKIA_TAG | cut -d '-' -f 1)"
        
        # Detect architecture
        if [[ $(uname -m) == "arm64" ]]; then
          ARCH="arm64"
        else
          ARCH="x64"
        fi
        
        echo "SKIA_TAG=$SKIA_TAG" >> $GITHUB_OUTPUT
        echo "SKIA_DIR_NAME=$SKIA_DIR_NAME" >> $GITHUB_OUTPUT
        echo "ARCH=$ARCH" >> $GITHUB_OUTPUT

    - name: Cache Skia
      id: cache-skia
      uses: actions/cache@v4
      with:
        path: ~/deps/${{ steps.skia-version.outputs.SKIA_DIR_NAME }}
        key: skia-${{ steps.skia-version.outputs.SKIA_TAG }}-macos-${{ steps.skia-version.outputs.ARCH }}-v3

    - name: Download Skia
      if: steps.cache-skia.outputs.cache-hit != 'true'
      run: |
        cd aseprite
        
        mkdir -p ~/deps/${{ steps.skia-version.outputs.SKIA_DIR_NAME }}
        cd ~/deps/${{ steps.skia-version.outputs.SKIA_DIR_NAME }}
        
        # Get the Skia URL
        if [ -f "$GITHUB_WORKSPACE/aseprite/laf/misc/skia-url.sh" ]; then
          SKIA_URL=$(bash $GITHUB_WORKSPACE/aseprite/laf/misc/skia-url.sh Release)
        else
          SKIA_URL="https://github.com/aseprite/skia/releases/download/${{ steps.skia-version.outputs.SKIA_TAG }}/Skia-macOS-Release-${{ steps.skia-version.outputs.ARCH }}.zip"
        fi
        
        echo "Downloading Skia from: $SKIA_URL"
        curl -L -o skia.zip "$SKIA_URL"
        unzip -n skia.zip
        rm skia.zip

    - name: Configure and Build
      run: |
        cd aseprite
        
        SOURCE_DIR="$PWD"
        BUILD_DIR="$PWD/build"
        SKIA_DIR="$HOME/deps/${{ steps.skia-version.outputs.SKIA_DIR_NAME }}"
        SKIA_LIBRARY_DIR="$SKIA_DIR/out/Release-${{ steps.skia-version.outputs.ARCH }}"
        
        # Configure with macOS deployment target
        cmake -B "$BUILD_DIR" -S "$SOURCE_DIR" -G Ninja \
              -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
              -DCMAKE_OSX_DEPLOYMENT_TARGET=11.0 \
              -DLAF_BACKEND=skia \
              -DSKIA_DIR="$SKIA_DIR" \
              -DSKIA_LIBRARY_DIR="$SKIA_LIBRARY_DIR"
        
        # Build
        cmake --build "$BUILD_DIR" -- aseprite

    - name: Package and Upload
      run: |
        cd aseprite
        tar -czf aseprite-macos-${{ env.BUILD_TYPE }}.tar.gz build/bin
        
    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: aseprite-macos-${{ env.BUILD_TYPE }}-${{ github.run_number }}
        path: aseprite/aseprite-macos-${{ env.BUILD_TYPE }}.tar.gz
        retention-days: 30

  release:
    name: Create Release
    permissions:
      contents: write
    needs: [build-windows, build-macos]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
    
    - name: Display structure
      run: ls -R artifacts
    
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        files: |
          artifacts/**/*.tar.gz
          artifacts/**/*.zip
        draft: false
        prerelease: false
        generate_release_notes: true
        body: |
          ## Aseprite Build
          
          This release includes builds for:
          - Windows (x64)
          - macOS (x64/arm64)
          
          ### Installation
          1. Download the appropriate archive for your platform
          2. Extract all files to a folder
          3. Run the aseprite executable
          
          ### Note
          These are unofficial builds. Please consider purchasing Aseprite from https://www.aseprite.org/ to support the developers.
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}